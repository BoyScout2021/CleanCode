# 깨끗한 코드가 존재하리라

## 코드가 존재하리라 

## 나쁜 코드 

## 나쁜 코드로 치르는 대가 

### 원대한 재설계의 꿈  

### 태도 

### 원초적 난제 


### 깨끗한 코드란? 

* 깨끗한 코드를 작성하려면 **`청결`** 이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 **절제와 규율이 필요하다.** 열쇠는 `코드 감각`이다. 어떤 사람은 코드 감각을 타고난다. **어떤 사람은 투쟁해서 얻어야 한다(투쟁해서라도 얻고 만다).** 
<br>=> 깨끗한 코드를 작성하려면 훈련이 필수적이구나.
* `코드 감각`이 있으면 좋은 코드와 나쁜 코드를 구분한다. 그뿐만이 아니다. 절제와 규율을 적용해 나쁜 코드를 **좋은 코드로 바꾸는 전략도 파악**한다. 
* `코드 감각`이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. **`코드 감각`으로 최고 방안을 선택한 후, 여기서 저기까지 이동하는 경로를 계획한다.** 

### 깨끗한 코드에 대한 대가들의 생각 

> 비야네 스트롭스트룹

* `보기에 즐거운` 코드. 잘 만든 오르골이나 잘 디자인된 차를 접할 때처럼 깨끗한 코드는 보는 사람에게 즐거움을 선사해야 한다는 뜻. 깔끔하게 잘 만든 코드 
*  효율적인 코드. 효율적인 코드에는 속도도 포함되지만, CPU 자원을 낭비하지 않는 코드도 포함된다. CPU 자원이 낭비되지 않게 런타임에 예측이 되는 코드를 작성하지 말고, 최대한 컴파일 타임에 결정되는 코드를 작성해야 한다.
* 코드를 망치려는 유혹을 주지 않는 코드. 나쁜 코드는 나쁜 코드를 유혹한다. 따라서 유혹하지 않게 애초에 깨끗한 코드를 작성하자(깨진 유리창).

> 그래디 부치

* 가독성이 좋은 코드. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 
* 명쾌한 추상화. 코드는 추측이 아니라 사실에 기반해야 한다.

> 데이브 토마스

* 깨끗한 코드는 **다른 사람이 고치기 쉽고** 읽기 쉬운 코드다. 다른 사람이 고치기 쉬울 정도로 쉬워야 한다.
* 테스트 케이스(단위 테스트, 인수 테스트 모두 포함)가 있는 코드. **아무리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다.**
* `최소`의 코드

> 마이클 페더스

* 깨끗한 코드는 언제나 누군가 **주의 깊게** 짰다는 느낌을 준다. 누군가 **시간을 들여 깔끔하고 단정하게 정리한 코드**다.

> 론 제프리스 

* 모든 테스트를 통과한다. 
* 중복이 없다. 
* 시스템 내 모든 설계 아이디어를 표현한다. 
* 클래스, 메서드, 함수 등을 최대한 줄인다.

> 워드 커닝햄

* 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 
* 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 
* 우리 업계에는 특정 언어를 신봉하는 광신자가 아주 많다. **하지만 프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다(언어가 Objective-C 라고 해도 불평하지 말자. 일단 Objective-C를 잘 쓰려고 노력하고 공부하자).**

## 우리들 생각 

* 이 책은 깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스를 만드는 방법을 소개한다. 지금까지 우리가 경험한 바로는 이 책에서 설명하는 교훈이, 적어도 우리(로버트C.마틴, 밥아저씨)에게는 **절대적인 진리**다. 이 책은 나와 내 동료들이 생각하는 깨끗한 코드를 정의한다.
* 우리가 가르치는 기법을 따른다면 깨끗하고 수준 높은 코드를 작성하리라 감히 장담한다(하지만 우리 생각이 절대적으로 `옳다`라는 단정은 금물이다).  
* 이 책은 우리가 오랫동안 고민하고 숙고한 교훈과 기법을 권고한다. **수십 년에 걸친 경험과 반복적인 시행착오로 습득한 교훈과 기법이다.** 

## 우리는 저자다 

* 코드를 작성하는 우리 프로그래머 모두는 **저자(@author)** 다. 저자에게는 독자(또 다른 프로그래머)가 있다. 다음에 코드를 짤 때는 자신이 저자라는 사실을, 여러분의 노력을 보고 판단을 내릴 독자(개발자)가 있다는 사실을 기억하고 더 나은 코드를 작성하기 위해 노력하라. 독자(개발자)와 잘 소통해야할 **책임**을 가지고 더 나은 코드를 작성하라. 왜? 독자도 결국 우리가 작성한 코드를 읽고 코드를 유지보수하고 기능 개발을 할 것이니깐!
* **코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다.** 새 코드를 짜면서 우리는 끊임없이 **기존 코드**를 읽는다. 따라서 비율이 이렇게 높으므로 **읽기 좋은 코드가 매우 중요**하다. 깨끗한 코드를 작성하기 위해 노력하자. 

## 보이스카우트 규칙 

* 잘 짠 코드가 전부가 아니다. **시간이 지나도 언제나 깨끗하게 유지해야 한다.**

* `캠프장은 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라`
<br>=> 코드를 작성하기 이전의 코드보다 좀 더 깨끗한 코드를 작성한다면 코드는 절대 나빠지지 않는다. 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다. **변수 이름 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if 문 하나를 정리하면 충분하다(오늘도 리팩토링 해보자).**

* 시간이 지날수록 **코드가 좋아지는 프로젝트에서** 작업한다고 상상해보라! 전문가라면 너무도 당연하지 않은가! **지속적인 개선이야말로 전문가 정신의 본질**이다.

## SOLID

* SRP(The Single Responsibility Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* OCP(The Open Closed Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* LSP(The Liscov Substitution Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* DIP(The Dependency Injection Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* ISP(The Interface Segregation Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

## 결론

* 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. 책은 단지 다른 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다. 이 책 역시 마찬가지다. 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 코드를 많이 읽고 직접 설계하고 코드를 작성하고, 리팩토링해서 더 나은 코드를 만들어봐야 한다. 나머지는 우리에게 달렸다.
* "연습해, 연습!" 
