# 1장. 깨끗한 코드  

## 코드가 존재하리라 

* 아무리 AI같은 `도구`가 생기고 발전하더라도 코드가 사라질 가망은 전혀 없다. 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능하기 때문이다. 정확히 명시하는 수밖에 없다. **기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업.** 바로 이것이 **프로그래밍**이다. 이렇게 명시한 결과가 **코드**다.  
* 제대로 명시한 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋다는 사실이다!
* 궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다. 코드는 항상 존재하리라.

## 나쁜 코드 

* 과거에 인기있던 한 프로그램이 제품 출시 주기가 늘어지고, 버그가 많이 생기고, 크래시도 많이 일어나게 되어 고객들이 많이 떠나가고 결국 망했다. 회사가 망한 원인은 **바로 나쁜 코드 탓**이었다. 
* 나쁜 코드에 발목이 잡혀 고생한 기억이 있는가? 조금이라도 프로그램을 짰다면 필경 수없이 경험했으리라. 심지어 이름도 있다. `고행`이라고 부른다.
* 르블랑의 법칙: `나중은 결코 오지 않는다.`

## 나쁜 코드로 치르는 대가 

> 나쁜 코드로 계속 작성하는 경우에 보이는 생산성 대 시간 그래프 

![productivity-vs-time](https://user-images.githubusercontent.com/38216027/115105667-559c8380-9f9b-11eb-84ab-f9ec4645192d.png)

* 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러다가 마침내 0에 접근한다. 

### 태도 

* 나쁜 코드의 책임은 일정을 촉박하게 만든 관리자 때문일까? 하지만 잘못은 전적으로 **우리 프로그래머**에게 있다. 
* 우리가 먼저 좋은 코드를 작성하기 위해 관리자에게 주장해서 **일정을 확보**하고, 좋은 코드를 작성해야 한다.
* 의사의 예처럼 프로그래머도 마찬가지다. **나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.**

### 원초적 난제 

* 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느낀다. 진짜 전문가는 이 말이 틀렸다는 사실을 잘 안다. **나쁜 코드를 양산하면 기한을 맞추지 못한다.** 오히려 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다. 기한을 맞추는 유일한 방법은, 그러니까 **빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관**이다. 

> 여기까지의 결론 

* 아무리 AI나 자동화가 발전해도 요구사항이 있는 한 코드는 존재하리라. 코드가 존재한다면 코드엔 나쁜 코드가 있고 나쁜 코드는 생산성을 악화시키는 위험 요소다. 따라서 우리는 나쁜 코드가 아닌 깨끗한 코드를 작성해야 한다. 

### 깨끗한 코드란? 

* 깨끗한 코드를 작성하려면 **`청결`** 이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 **절제와 규율이 필요하다.** 열쇠는 `코드 감각`이다. 어떤 사람은 코드 감각을 타고난다. **어떤 사람은 투쟁해서 얻어야 한다(투쟁해서라도 얻고 만다).** 
<br>=> 깨끗한 코드를 작성하려면 훈련이 필수적이구나.
* `코드 감각`이 있으면 좋은 코드와 나쁜 코드를 구분한다. 그뿐만이 아니다. 절제와 규율을 적용해 나쁜 코드를 **좋은 코드로 바꾸는 전략도 파악**한다. 
* `코드 감각`이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. **`코드 감각`으로 최고 방안을 선택한 후, 여기서 저기까지 이동하는 경로를 계획한다.** 

### 깨끗한 코드에 대한 대가들의 생각 

> 비야네 스트롭스트룹

* `보기에 즐거운` 코드. 잘 만든 오르골이나 잘 디자인된 차를 접할 때처럼 깨끗한 코드는 보는 사람에게 즐거움을 선사해야 한다는 뜻. 깔끔하게 잘 만든 코드. 
*  효율적인 코드. 효율적인 코드에는 속도도 포함되지만, CPU 자원을 낭비하지 않는 코드도 포함된다. CPU 자원이 낭비되지 않게 런타임에서야 예측이 되는 코드를 작성하지 말고, 최대한 컴파일 타임에 결정되는 코드를 작성해야 한다.
* 코드를 망치려는 유혹을 주지 않는 코드. 나쁜 코드는 나쁜 코드를 유혹한다. 따라서 유혹하지 않게 애초에 깨끗한 코드를 작성하자(깨진 창문).

> 그래디 부치

* 가독성이 좋은 코드. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 
* 명쾌한 추상화. 코드는 추측이 아니라 사실에 기반해야 한다.

> 데이브 토마스

* 깨끗한 코드는 **다른 사람이 고치기 쉽고** 읽기 쉬운 코드다. 다른 사람이 고치기 쉬울 정도로 쉬워야 한다.
* 테스트 케이스(단위 테스트, 인수 테스트 모두 포함)가 있는 코드. **아무리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다.**
* `최소`의 코드

> 마이클 페더스

* 깨끗한 코드는 언제나 누군가 **주의 깊게** 짰다는 느낌을 준다. 누군가 **시간을 들여 깔끔하고 단정하게 정리한 코드**다.

> 론 제프리스 

* **모든 테스트를 통과한다(테스트가 이렇게 중요하다).**
* 중복이 없다. 
* 시스템 내 모든 설계 아이디어를 표현한다. 
* 클래스, 메서드, 함수 등을 최대한 줄인다.

> 워드 커닝햄

* 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 
* 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 
* 우리 업계에는 특정 언어를 신봉하는 광신자가 아주 많다. **하지만 프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다(언어가 Objective-C 라고 해도 불평하지 말자. 일단 Objective-C를 잘 쓰려고 노력하고 공부하자).**

## 우리들 생각 

* 이 책은 깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스를 만드는 방법을 소개한다. 지금까지 우리가 경험한 바로는 이 책에서 설명하는 교훈이, 적어도 우리(로버트C.마틴, 밥아저씨)에게는 **절대적인 진리**다. 이 책은 나와 내 동료들이 생각하는 깨끗한 코드를 정의한다.
* 우리가 가르치는 기법을 따른다면 깨끗하고 수준 높은 코드를 작성하리라 감히 장담한다(하지만 우리 생각이 절대적으로 `옳다`라는 단정은 금물이다).  
* 이 책은 우리가 오랫동안 고민하고 숙고한 교훈과 기법을 권고한다. **수십 년에 걸친 경험과 반복적인 시행착오로 습득한 교훈과 기법이다.** 

## 우리는 저자다 

* 코드를 작성하는 우리 프로그래머 모두는 **저자(@author)** 다. 저자에게는 독자(또 다른 프로그래머)가 있다. 다음에 코드를 짤 때는 자신이 저자라는 사실을, 여러분의 노력을 보고 판단을 내릴 독자(개발자)가 있다는 사실을 기억하고 더 나은 코드를 작성하기 위해 노력하라. 독자(개발자)와 잘 소통해야할 **책임**을 가지고 더 나은 코드를 작성하라. 왜? 독자도 결국 우리가 작성한 코드를 읽고 코드를 유지보수하고 기능 개발을 할 것이니깐!
* **코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다.** 새 코드를 짜면서 우리는 끊임없이 **기존 코드**를 읽는다. 따라서 비율이 이렇게 높으므로 **읽기 좋은 코드가 매우 중요**하다. 깨끗한 코드를 작성하기 위해 노력하자. 

## 보이스카우트 규칙 

* 잘 짠 코드가 전부가 아니다. **시간이 지나도 언제나 깨끗하게 유지해야 한다.**

* `캠프장은 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라`
<br>=> 코드를 작성하기 이전의 코드보다 좀 더 깨끗한 코드를 작성한다면 코드는 절대 나빠지지 않는다. 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다. **변수 이름 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if 문 하나를 정리하면 충분하다(오늘도 리팩토링 해보자).**

* 시간이 지날수록 **코드가 좋아지는 프로젝트에서** 작업한다고 상상해보라! 전문가라면 너무도 당연하지 않은가! **지속적인 개선이야말로 전문가 정신의 본질**이다.

## SOLID

* SRP(The Single Responsibility Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* OCP(The Open Closed Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* LSP(The Liscov Substitution Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* DIP(The Dependency Injection Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

* ISP(The Interface Segregation Principle)
<br>: 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다. 

## 결론

* 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. 책은 단지 다른 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다. 이 책 역시 마찬가지다. 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 코드를 많이 읽고 직접 설계하고 코드를 작성하고, 리팩토링해서 더 나은 코드를 만들어봐야 한다. 나머지는 우리에게 달렸다.
* "연습해, 연습!" 

## 김도형이 생각하는 깨끗한 코드를 작성해야 하는 이유

* 깨끗한 코드를 작성하는 일은 **내 밥벌이, 동료들(PM 포함) 밥벌이 더 나아가 회사의 미래까지 책임지는 일**이기 때문에 깨끗한 코드를 작성해야 한다고 생각한다. **깨끗한 코드를 작성하면, 생산성이 줄어들지 않고 프로그램이 계속 굴러가고 회사가 망하지 않기 때문에** 깨끗한 코드를 작성해야 한다고 생각한다.    