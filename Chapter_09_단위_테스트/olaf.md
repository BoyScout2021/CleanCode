# 9장 단위 테스트

## TDD 법칙 세 가지

1. 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일이 될 정도의 테스트 코드를 작성한다.(실패한다)
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 수정한다.

위 방법을 사용하면 실제 코드를 전부 테스트 할 수 있는 테스트 케이스가 나온다. 하지만 이렇게 많은 테스트 케이스는 관리가 어렵다는 문제가 생길수도 있다.

<br>

## 깨끗한 테스트 코드 유지하기

`지저분해도 빨리` 작성할 수 있는 단위 테스트? 그러니까 테스트 코드를 분리하지 않고, 주의해서 설계를 하지 않고 그저 실제 코드를 테스트만 하면 그만인가? 아니다. 지저분한 테스트 코드는 테스트를 하나 안하나 거기서 거기다. 오히려 더 안좋을수도 있다. 실제 코드가 변하면 테스트코드도 변해야하는데, 테스트 코드가 지저분할 수록 변경하기 어렵기 때문.

즉 `테스트 코드는 실제 코드 못지 않게 중요하다.`

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아무리 아키텍쳐가 유연하더라도, 설계를 아무리 잘 했더라도, 테스트 케이스가 없으면 언제든 버그가 숨어들 수 있다.

그러므로 실제 코드의 단위 테스트는 설계와 아키텍쳐를 최대한 깨끗하게 보존할 수 있게 해준다. 테스트 케이스가 있으면 변경이 쉬워지기 때문에, `유연성, 유지보수성, 재사용성`을 제공한다.

<br>

## 깨끗한 테스트 코드

깨끗한 테스트 코드를 만들려면? -> 가독성!!!

온갖 잡다하고 무관한 코드를 이해한 후에 테스트 케이스를 이해하는 것은 상당히 비효육적이다. 따라서 테스트 코드는 잡다하고 세세한 코드를 없애야 한다. 테스트 코드는 진짜 필요한 자료 유형과 함수만 사용한다. 그러므ㅜ로 코드를 읽는 사람은 코드가 수행하는 기능을 재빨리 이해할 수 있다.

> Build - Operate - Check 패턴
>
> 첫 부분은 테스트 자료를 만든다
>
> 두번째 부분은 테스트 자료를 조작한다
>
> 세번째 부분은 조작한 결과가 올바른지 확인한다.
>
> 이거 given, when, then 아닌가...?

<br>

### 테스트 당 assert 하나

assert문이 하나인 메소드는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. assert문을 하나로 합치는 것이 불합리해 보인다면, 테스트를 여러개로 쪼개자. 이렇게 분리했을 때, 중복되는 코드가 많이 생긴다면 given, when 부분을 부모 클래스에 두고 then을 자식 클래스에서 하는 `Template Method` 패턴을 사용해도 좋다.

`개념 당 asser 문 수를 최소로 줄여라`, `테스트 메소드 하나는 개념 하나만 테스트 하라.`

<br>

## F.I.R.S.T

### First

테스트는 빨라야한다. 빨라야 자주 돌릴 수 있기 때문이다. 느린 테스트 코드 때문에 테스트 돌리는 것을 주저한다면, 결국 코드 품질 저하로 이어진다

### Independent

각 테스트는 서로 의존하면 안된다. 테스트의 결과가 다른 테스트에 영향을 주면 안된다는 말이다. 테스트 하나가 실패했을 때 다른 테스트도 그 결과에 의해 실패할 수 있기 때문이다. 이는 원인 진단을 어렵게 만든다.

### Repeatable

테스트는 어떤 환경에도 실행 가능해야한다. 네트워크에 의존하면 안된다.

### Self-Validation

테스트의 결과로 로그 파일이 생성되고, 이를 개발자가 직접 읽고 테스트 결과를 판단하면 안된다. 즉 테스트 결과로 성공, 실패가 반환되어야 한다.

### Timely

테스트는 적시에 작성해야 한다. 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 작성한다. 실제 코드를 작성 후 테스트 코드를 작성하려 한다면, 분명 테스트가 어려운 지점이 발생한다. 이를 테스트를 먼저 작성하여 테스트가 가능한 코드가 나오도록 하자.

 